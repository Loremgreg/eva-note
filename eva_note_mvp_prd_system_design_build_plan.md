# PT AI Notes MVP ‚Äî PRD, System Design & Build Plan

*Last updated: 23 Sep 2025*

---


## 1) PRD ‚Äî Product Requirements Document

### 1.1 Contexte & probl√®me

Les kin√©sith√©rapeutes passent trop de temps √† documenter les s√©ances (notes SOAP) apr√®s les heures. La qualit√© et la constance de ces notes varient, et les relire/structurer est chronophage.

### 1.2 Objectif MVP

Cr√©er une application web simple qui permet :

1. **Enregistrer la s√©ance** (audio du navigateur, conversation en direct: Live transcription (streaming))¬†
2. **Transcrire** l‚Äôaudio (STT streaming temps r√©el via Deepgram WebSocket),
3. **G√©n√©rer automatiquement une note SOAP** via un LLM **Azure OpenAI EU** (via SDK Azure ou Vercel AI SDK configur√© Azure) √† partir du transcript,
4. **R√©viser / √©diter / sauvegarder** la note et l‚Äôattacher au patient/√† la visite.


### 1.3 Port√©e (MVP)

**Inclus**

- Authentification via **Clerk** (UI & sessions, tenant en **r√©gion EU**, UI par d√©faut en **allemand**).
- Gestion minimale des patients (CRUD basique : cr√©er/lister/s√©lectionner, champs **pr√©nom/nom uniquement**).
- D√©marrer une **visite**, enregistrer l‚Äôaudio du navigateur (**streaming temps r√©el**) **ou** saisir du texte manuellement.
- Transcription **streaming temps r√©el** via Deepgram WebSocket (**Nova-3 DE**) avec sous-titres live (partials) et transcript final.
- G√©n√©ration **SOAP d√©taill√©e** (S/O/A/P) via **Azure OpenAI EU** (via SDK Azure ou Vercel AI SDK configur√© Azure).
- √âdition manuelle et **sauvegarde** de la note.
- Export **copier/coller format√©** (pas de PDF pour MVP).

**Hors scope (plus tard)**

- Int√©grations EMR/ERP.
- HEP (home exercise program) auto.
- G√©n√©ration plan traitement EBP¬†
- Mobile app native.
- Multilingue complet (FR/DE/EN).

### 1.4 Personae

- **PT Solo** : kin√© ind√©pendant qui veut gagner du temps sur la doc.
- **PT Multi-cabinet (v2)** : responsable d‚Äôun petit cabinet (2‚Äì5 PT), besoin de coh√©rence documentaire.

### 1.5 User stories principales (MVP)

1. **En tant que PT**, je peux me connecter avec Clerk pour acc√©der √† mon espace s√©curis√©.\
   *AC:* redirection si non connect√© ; profil visible ; logout dispo.
2. **En tant que PT**, je peux cr√©er un **patient** (nom, pr√©nom ).\
   *AC:* validations basiques, liste pagin√©e.
3. **En tant que PT**, je peux d√©marrer une **visite** pour un patient, soit **dicter** (**streaming temps r√©el**), soit **√©crire manuellement**.\
   *AC:* √©tat clair (enregistrement streaming, en cours de transcription live, ou saisie manuelle).
4. **En tant que PT**, apr√®s transcription ou saisie, je peux **g√©n√©rer une note SOAP d√©taill√©e** automatique, la **relire**, **√©diter**, **sauvegarder**.\
   *AC:* sections S/O/A/P pr√©‚Äëremplies ; modifiables ; bouton ¬´ enregistrer ¬ª ; horodatage.
5. **En tant que PT**, je peux copier la note.\
   *AC:*¬†texte format√©, encodage UTF‚Äë8.

### 1.6 KPI / succ√®s

- ‚è±Ô∏è **Latence live** des sous-titres < 1 s ; g√©n√©ration SOAP < 10 s apr√®s arr√™t.
- üìÑ **Taux d‚Äô√©dition** (pour affiner le prompt & UX) : % de notes modifi√©es < 70% √† terme.
- ‚úÖ **Taux de compl√©tion** (du flux "enregistrer/√©crire ‚Üí note sauvegard√©e") > 80%.

### 1.7 Contraintes & conformit√©

- **Langue par d√©faut** : allemand (DE). Multilingue possible en phase ult√©rieure.
- **S√©curit√© des donn√©es** : audio, transcript, note = **priv√©s** (pas de public bucket).
- **Suppression audio** : suppression **imm√©diate** apr√®s transcription (aucune r√©tention).
- **GDPR** : pr√©voir consentement patient (textuel) pour enregistrement (v2: banni√®re/checkbox).
- **R√©glementaire** : cibles initiales hors remboursement/assureur pour MVP ; contenu documentaire doit rester **revu par le PT**.
- **Co√ªts** : limiter appels LLM/STT (quota & alertes) ; choisir le **mod√®le IA le moins cher** utilisable.

### 1.8 Hypoth√®ses & validations techniques

**Audio streaming (√† v√©rifier avant d√©veloppement) :**
- Format : `audio/webm;codecs=opus` (Chrome/Edge) ou `audio/ogg;codecs=opus` (Firefox).
- Deepgram WebSocket accepte le stream Opus natif sans r√©encodage serveur.
- Fallback : si `opus` non support√© ‚Üí `audio/webm` (codec par d√©faut du navigateur).
- Navigateur cible MVP : Chrome, Edge ou Firefox Desktop (Safari non support√© au MVP).

**Tests pr√©liminaires obligatoires :**
- [ ] Cr√©er un compte Deepgram et tester l'envoi d'un flux Opus via WebSocket.
- [ ] Confirmer qu'Azure OpenAI d√©ploie `gpt-4o-mini` en r√©gion `germanywestcentral`.

**Notes techniques additionnelles :**
- D√©tection dynamique c√¥t√© client : `MediaRecorder.isTypeSupported('audio/webm;codecs=opus')` sinon fallback `audio/ogg;codecs=opus`.
- Si aucun format support√© : afficher un message d‚Äôerreur clair ‚Üí ¬´ Utilisez Chrome/Edge/Firefox desktop pour l‚Äôenregistrement live (MVP) ¬ª.
- Phase 1.5 possible : conversion serveur (re-encode PCM 16 kHz mono via FFmpeg) pour compatibilit√© Safari.

---

## 2) Architecture

### 2.1 Vue d‚Äôensemble

- **Next.js 15 (App Router)** ‚Äî UI, routes API, Server Actions.
- **Clerk (EU tenant, UI en DE)** ‚Äî Auth (UI + session).
- **Supabase** ‚Äî Postgres (r√©gion EU). **Pas de stockage audio** au MVP (stream only).
- **Deepgram STT** ‚Äî **streaming temps r√©el** (WebSocket) en allemand **Nova-3 DE** (partials + transcript final).
- **Azure OpenAI EU** (via SDK Azure ou Vercel AI SDK configur√© Azure) ‚Äî g√©n√©ration note SOAP.

**Flux (Phase 1 ‚Äî MVP)**

1. PT d√©marre **Visite** ‚Üí choisit **Dicter** (streaming) ou **√âcrire**.
2. Si audio : le client ouvre un **WebSocket** vers **/api/stt/stream** (proxy serveur) ‚Üí le serveur relaye vers Deepgram WS.
3. **Transcription live** : l‚ÄôUI affiche les **partials** en temps r√©el ; √† l‚Äôarr√™t, on re√ßoit un **transcript final**.
4. **Aucun stockage audio** : seul le **transcript** est enregistr√© en base (GDPR).
5. Serveur ‚Üí **Azure OpenAI EU** pour g√©n√©rer la note SOAP.

### 2.2 S√©quence d√©taill√©e (streaming WebSocket)

**Phase 1 : Connexion & streaming**
1. Client ‚Üí ouvre WebSocket `/api/stt/stream` (auth Clerk via cookie/header).
2. Serveur ‚Üí v√©rifie auth, ouvre connexion Deepgram WebSocket (`wss://api.deepgram.com/v1/listen?model=nova-3&language=de`).
3. Client ‚Üí envoie des chunks audio (Opus) via WebSocket toutes les ~200‚ÄØms.
4. Deepgram ‚Üí renvoie des √©v√©nements `Results` (partials) en temps r√©el.
5. Serveur ‚Üí relaye ces partials au client (affichage live des sous-titres).

**Phase 2 : Arr√™t & finalisation**
6. Client ‚Üí clique "Stop" ‚Üí envoie message `{"type":"stop"}` au serveur.
7. Serveur ‚Üí envoie `{"type":"CloseStream"}` √† Deepgram (d√©clenche la finalisation du flux audio).
8. Deepgram ‚Üí renvoie √©v√©nement `SpeechFinal` (ou √©quivalent) avec le transcript complet.
8bis. Serveur ‚Üí attend jusqu‚Äô√† **3‚ÄØs** la r√©ception des √©v√©nements finals. Si aucun final n‚Äôarrive, il utilise le dernier segment final connu (ou √† d√©faut le dernier partial) et loggue un avertissement.
9. Serveur ‚Üí enregistre `transcripts(visit_id, text, raw_json)` en base.
10. Serveur ‚Üí ferme WebSocket avec code **4001 CLIENT_CLOSED**.
11. Client ‚Üí affiche "Transcript enregistr√©" et passe √† la g√©n√©ration SOAP.

**Gestion timeout (30‚ÄØs sans audio)**
- Serveur ‚Üí `setTimeout` qui envoie `CloseStream` √† Deepgram apr√®s 30‚ÄØs d‚Äôinactivit√©.
- Deepgram ‚Üí renvoie `SpeechFinal` si possible.
- Serveur ‚Üí enregistre et ferme avec code **4000 INACTIVITY_TIMEOUT**.

---

## 3) R√©silience & Gestion d‚Äôerreurs (MVP)

### Probl√®me identifi√©

- **Retry automatique** : r√©essayer 2‚Äì3 fois en cas d‚Äô√©chec (avec petit d√©lai progressif entre les tentatives).
- **Plan B** : si apr√®s plusieurs tentatives cela √©choue, proposer √† l‚Äôutilisateur un mode **Saisie manuelle** (il √©crit directement son texte).
- **Feedback clair** : afficher l‚Äô√©tat (ex. ¬´ transcription en cours‚Ä¶ tentative 2/3 ¬ª, ¬´ √©chec ‚Üí r√©essayer ou saisir manuellement ¬ª).
- **Aucune donn√©e audio persist√©e** : en cas d‚Äô√©chec, le flux est simplement interrompu (GDPR).


> **Approche MVP** : Retry simple c√¥t√© client.  
> Le navigateur tente jusqu‚Äô√† 3 fois de reconnecter le flux audio √† Deepgram, avec un d√©lai progressif.  
> Si toutes les tentatives √©chouent, on affiche un message clair et propose la saisie manuelle.  
> Aucun syst√®me de queue serveur (ex. BullMQ) n‚Äôest utilis√© pour le MVP.

```ts
// MVP : retry simple c√¥t√© client (pas de queue serveur)
// Tentatives de reconnexion automatiques √† Deepgram (3x max), avec backoff progressif.
// Fallback : saisie manuelle si tout √©choue.

async function transcribeWithRetry(audioStream: MediaStream, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      // Tentative de connexion WebSocket √† Deepgram
      return await connectDeepgramWS(audioStream);
    } catch (error) {
      console.warn(`Transcription tentative ${attempt} √©chou√©e`, error);

      if (attempt === maxRetries) {
        // Fallback : saisie manuelle
        showToast('Transcription √©chou√©e ‚Üí Saisie manuelle ?');
        return null;
      }

      // Backoff progressif avant nouvel essai (1s, 2s, 3s‚Ä¶)
      await sleep(1000 * attempt);
    }
  }
}

// Helper sleep
function sleep(ms: number) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
```

### Politique Streaming WebSocket (MVP)

> **Timeout**: si aucun audio re√ßu pendant 30s, le serveur ferme la connexion WebSocket.
> **Un seul reconnect**: le client peut tenter une reconnexion automatique une seule fois si la connexion est perdue.
> **Feedback UI**: l‚Äôutilisateur est notifi√© si la connexion WebSocket est perdue ou si un timeout survient.

```ts
// Exemple (client) : reconnexion unique
let hasReconnected = false;
ws.onclose = () => {
  if (!hasReconnected) {
    hasReconnected = true;
    reconnectWebSocket();
  }
};
// Serveur : timeout si pas de donn√©es
setTimeout(() => {
  if (!audioReceivedRecently) ws.close();
}, 30000);
```


### Gestion WebSocket (heartbeat / timeout / reconnexion)

```ts
// Heartbeat + timeout
const WS_TIMEOUT_MS = 30000; // 30s sans audio ‚Üí fermeture
const HEARTBEAT_INTERVAL_MS = 10000; // ping/10s

// Reconnexion automatique (1 seule fois)
if (ws.readyState === WebSocket.CLOSED && !hasReconnected) {
  hasReconnected = true;
  reconnectWebSocket();
}
```

#### Codes de fermeture & comportement (serveur)
- **4000 INACTIVITY_TIMEOUT** : aucun audio re√ßu pendant `WS_TIMEOUT_MS` ‚Üí fermeture c√¥t√© serveur. Tenter d‚Äôenvoyer le **final transcript** si disponible avant `close`.
- **4001 CLIENT_CLOSED** : l‚Äôutilisateur clique **Stop** ‚Üí envoyer le **final transcript**, fermer proprement.
- **4002 PROXY_ERROR** : erreur r√©seau/proxy lors du relay WS ‚Üí fermeture et log technique (sans PII).
- **Remarque** : toujours terminer la session en essayant d‚Äô√©mettre les derni√®res hypoth√®ses **finales** de Deepgram si disponibles.

-#### Feedback UI (toasts & √©tats)
- Toasts : ¬´ Verbindung verloren ¬ª / ¬´ Wiederverbinden‚Ä¶ ¬ª / ¬´ Timeout (30s ohne Audio) ¬ª / ¬´ Stream beendet ¬ª / ¬´ Finales Transkript gespeichert ¬ª / ¬´ Fehler ‚Üí Manuelle Eingabe ? ¬ª
- Pendant la fermeture : **d√©sactiver** le bouton *Stop* et afficher un spinner ¬´ Beenden‚Ä¶ ¬ª jusqu‚Äô√† `onclose`.
- En cas d‚Äô√©chec de reconnexion (apr√®s 1 tentative) : proposer le **fallback Saisie manuelle**.


### Gestion des transcripts vides ou trop courts

**Crit√®res de validation :**
- Si `transcript.text.length < 20` caract√®res ‚Üí afficher un toast ¬´ Transcript trop court ¬ª (DE: *Zu kurz*).
- Proposer deux actions : **R√©essayer** OU **Saisie manuelle**.
- **Ne pas** enregistrer dans `transcripts` si vide/insuffisant.
- **Ne pas** appeler Azure OpenAI tant qu‚Äôaucun transcript **valide** n‚Äôest disponible.

**Code exemple (validation serveur) :**
```ts
// √Ä placer juste avant l‚Äôinsertion DB et l‚Äôappel LLM
if (!transcript || transcript.trim().length < 20) {
  return {
    error: 'TRANSCRIPT_TOO_SHORT',
    message: 'Zu kurz ‚Äì bitte erneut aufnehmen ou manuell eingeben.'
  }
}
```

-### B√©n√©fices
- L‚Äôutilisateur n‚Äôest jamais bloqu√© : il a toujours une solution (r√©essayer ou saisir √† la main).
- L‚Äôexp√©rience est claire : il comprend ce qui se passe et peut agir.
- Pas besoin d‚Äôinfrastructure complexe (pas de queue Redis/BullMQ) pour le MVP, mais la logique est pr√™te √† √©voluer si la charge augmente.


---
-## 4) S√©curit√© & GDPR (MVP)

- **H√©bergement EU** obligatoire : Supabase (EU), Clerk (EU), stockage et traitement en r√©gion europ√©enne.
- **LLM en r√©gion EU** : utiliser Azure OpenAI (d√©ploiement Europe) ou √©quivalent (ex. AWS Bedrock avec Claude, Vertex AI EU) afin de garantir qu‚Äôaucune donn√©e patient ne quitte l‚ÄôUE.
- **Aucun fichier audio stock√© au MVP (streaming)** ; seul le transcript est conserv√©.
- **Buckets priv√©s** : tous les transcripts et notes sont stock√©s en priv√©, jamais en public.
- **Consentement patient** : pr√©voir une √©tape d‚Äôinformation et consentement avant l‚Äôenregistrement (phase suivante : banni√®re ou checkbox).
- **Logs** : ne jamais logguer le contenu patient (seulement les IDs, erreurs techniques anonymis√©es).

### S√©curit√© additionnelle (MVP)

**CORS (WebSocket & API) :**
- Origines autoris√©es : `https://<ton-domaine>.vercel.app` (production) + `http://localhost:3000` (dev).
- Rejeter toutes les autres origines.

**Rate limiting (MVP simple) :**
- Max **3 visites/heure** par utilisateur (c√¥t√© serveur via Clerk `userId`).
- Max **3 connexions WebSocket simultan√©es** par utilisateur.
- Si d√©pass√© ‚Üí **HTTP 429** avec message ¬´ Zu viele Anfragen ‚Äì bitte warten ¬ª.

**Validation payload :**
- Taille max **chunk audio** : **1 MB/chunk** (rejeter si plus grand).
- Dur√©e max visite : **15 min (900 s)** ‚Üí fermeture automatique apr√®s.
- Longueur max **saisie manuelle** : **10‚ÄØ000 caract√®res**.

**Code exemple (middleware Next.js) :**
```ts
// middleware.ts
import { ratelimit } from '@/lib/ratelimit' // ex: upstash/redis
import { auth } from '@clerk/nextjs'
import { NextRequest, NextResponse } from 'next/server'

export async function middleware(req: NextRequest) {
  const { userId } = auth()
  if (!userId) return NextResponse.redirect(new URL('/sign-in', req.url))
  
  const { success } = await ratelimit.limit(userId)
  if (!success) return new Response('Too Many Requests', { status: 429 })
  
  return NextResponse.next()
}
```

### Azure OpenAI EU ‚Äî Int√©gration & Garde-fous (MVP)
- **Endpoint unique (EU)** : `AZURE_OPENAI_ENDPOINT` pointe vers la ressource Azure en Europe ; `AZURE_OPENAI_REGION` ‚àà {westeurope, northeurope, francecentral, germanywestcentral, swedencentral, norwayeast, switzerlandnorth, polandcentral}. L‚Äôapplication **refuse de d√©marrer** si la r√©gion n‚Äôest pas UE.
- **Pas de fallback** : **un seul module serveur** centralise tous les appels LLM ; interdiction d‚Äôutiliser l‚ÄôAPI OpenAI standard ailleurs.
- **Serveur uniquement** : appels LLM exclusivement via **routes API/Server Actions** ; **jamais** depuis le navigateur ; cl√©s **non expos√©es** au client.
- **D√©ploiement explicite** : usage du **nom de d√©ploiement Azure** (ex. `gpt-4o-mini-eu`) et `response_format: json_object` ; **validation JSON** c√¥t√© serveur (Zod).
- **Logs minimaux** : journaliser seulement des m√©tadonn√©es techniques (dur√©e, mod√®le, statut) ‚Äî **jamais** de contenu patient.
- **V√©rifs CI** : contr√¥le automatique qu‚Äôaucun `import 'openai'` n‚Äôest utilis√© hors du module d√©di√©.

### Variables d'environnement ‚Äî Azure OpenAI EU (MVP)
```env
AZURE_OPENAI_ENDPOINT=https://<resource-name>.openai.azure.com
AZURE_OPENAI_API_KEY=***
AZURE_OPENAI_REGION=germanywestcentral   # ex: westeurope | francecentral | northeurope | switzerlandnorth ...
AZURE_OPENAI_DEPLOYMENT=gpt-4o-mini-eu   # nom du d√©ploiement Azure, pas le nom g√©n√©rique du mod√®le
AZURE_OPENAI_API_VERSION=2024-02-01
LLM_MAX_OUTPUT_TOKENS=1024
```
> Remarque : ces variables sont **serveur uniquement** (jamais c√¥t√© client). Le code **√©choue au d√©marrage** si `AZURE_OPENAI_REGION` n‚Äôest pas une r√©gion UE autoris√©e.

### B√©n√©fices
- R√©duit le risque l√©gal li√© au GDPR.
- Augmente la confiance utilisateur (kin√©s + patients).
- Pr√©pare le terrain pour une certification future (CE m√©dical, etc.).
- Garantit que le traitement IA (LLM) reste conforme RGPD d√®s le MVP clinique.

---

## 5) Mod√®le de donn√©es (Supabase)

### 5.1 Vue d‚Äôensemble (simple)
Objectif : garantir des liens clairs **PT ‚Üí Patients ‚Üí Visits ‚Üí Transcripts ‚Üí Notes**, la propri√©t√© des donn√©es par le kin√©, et la compatibilit√© avec **Clerk** (pas Supabase Auth).

### 5.2 Sch√©ma lisible (tables & champs)
- **profiles** ‚Äî profil du kin√© (liaison avec Clerk)
  - `id` (UUID, PK)
  - `clerk_user_id` (TEXT, unique) ‚Äî l‚ÄôID utilisateur venant de Clerk
  - `email` (TEXT), `full_name` (TEXT)
  - `created_at` (TIMESTAMPTZ)

- **patients** ‚Äî patients du kin√©
  - `id` (UUID, PK)
  - `owner_id` (UUID ‚Üí profiles.id)
  - `first_name` (TEXT), `last_name` (TEXT)
  - `created_at`, `updated_at`

- **visits** ‚Äî visites par patient
  - `id` (UUID, PK)
  - `patient_id` (UUID ‚Üí patients.id)
  - `provider_id` (UUID ‚Üí profiles.id)
  - `status` (TEXT : `draft|recording|processing|completed|failed`)
  - `language_pref` (TEXT : `de|fr|auto`, d√©faut `de`)
  - `started_at`, `ended_at`, `created_at`, `updated_at`

- **transcripts** ‚Äî texte issu de Deepgram
  - `id` (UUID, PK)
  - `visit_id` (UUID ‚Üí visits.id)
  - `text` (TEXT), `raw_json` (JSONB)
  - `language` (TEXT), `confidence` (NUMERIC)
  - `created_at`
  - Pas de versioning au MVP : une seule note active par visite, autosave + champ `is_final`.

- **notes** ‚Äî note SOAP
  - `id` (UUID, PK)
  - `visit_id` (UUID ‚Üí visits.id)
  - `soap` (JSONB : {subjective, objective, assessment, plan})
  - `model` (TEXT) ‚Äî ex. `openai:gpt-4o-mini`
  - `version` (INT, d√©faut 1), `is_final` (BOOL, d√©faut false)
  - `created_at`

### 5.3 SQL (MVP)
> √Ä ex√©cuter dans Supabase (projet en **r√©gion EU**). Utilise `gen_random_uuid()` (extension `pgcrypto`).
```sql
create extension if not exists pgcrypto;

-- 1) PROFILS (liaison Clerk)
create table if not exists profiles (
  id uuid primary key default gen_random_uuid(),
  clerk_user_id text unique not null,
  email text,
  full_name text,
  created_at timestamptz default now()
);

-- 2) PATIENTS
create table if not exists patients (
  id uuid primary key default gen_random_uuid(),
  owner_id uuid not null references profiles(id) on delete cascade,
  first_name text not null,
  last_name text not null,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);
create index if not exists idx_patients_owner on patients(owner_id);

-- 3) VISITS
create table if not exists visits (
  id uuid primary key default gen_random_uuid(),
  patient_id uuid not null references patients(id) on delete cascade,
  provider_id uuid not null references profiles(id) on delete cascade,
  status text not null check (status in ('draft','recording','processing','completed','failed')) default 'draft',
  language_pref text not null check (language_pref in ('de','fr','auto')) default 'de',
  started_at timestamptz,
  ended_at timestamptz,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);
create index if not exists idx_visits_patient on visits(patient_id);
create index if not exists idx_visits_provider on visits(provider_id);

-- 4) TRANSCRIPTS
create table if not exists transcripts (
  id uuid primary key default gen_random_uuid(),
  visit_id uuid not null references visits(id) on delete cascade,
  text text,
  raw_json jsonb,
  language text,
  confidence numeric,
  created_at timestamptz default now()
);
create index if not exists idx_transcripts_visit on transcripts(visit_id);

-- 5) NOTES (SOAP)
create table if not exists notes (
  id uuid primary key default gen_random_uuid(),
  visit_id uuid not null references visits(id) on delete cascade,
  soap jsonb not null,
  model text,
  version int default 1,
  is_final boolean default false,
  created_at timestamptz default now()
);
create index if not exists idx_notes_visit on notes(visit_id);

-- 6) Triggers updated_at
create or replace function set_updated_at() returns trigger as $$
begin
  new.updated_at = now();
  return new;
end; $$ language plpgsql;

drop trigger if exists set_patients_updated_at on patients;
create trigger set_patients_updated_at before update on patients
for each row execute procedure set_updated_at();

drop trigger if exists set_visits_updated_at on visits;
create trigger set_visits_updated_at before update on visits
for each row execute procedure set_updated_at();

-- 6) USAGE METRICS (co√ªts par visite)
create table if not exists usage_metrics (
  id uuid primary key default gen_random_uuid(),
  visit_id uuid not null references visits(id) on delete cascade,
  -- STT
  stt_seconds integer not null default 0,
  stt_cost_cents integer not null default 0,
  -- LLM
  llm_tokens_in integer not null default 0,
  llm_tokens_out integer not null default 0,
  llm_cost_cents integer not null default 0,
  -- Total (g√©n√©r√© = stt + llm)
  total_cost_cents integer generated always as
    (coalesce(stt_cost_cents,0) + coalesce(llm_cost_cents,0)) stored,
  -- Traces utiles
  stt_model text,          -- ex: deepgram:nova-3
  llm_model text,          -- ex: azure:gpt-4o-mini-eu
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create index if not exists idx_usage_metrics_visit on usage_metrics(visit_id);
create index if not exists idx_usage_metrics_created on usage_metrics(created_at);

-- Vue mensuelle simple (montants en EUR)
create or replace view monthly_usage as
select
  date_trunc('month', created_at) as month,
  count(distinct visit_id) as visits,
  sum(stt_seconds) as total_stt_seconds,
  sum(total_cost_cents)/100.0 as total_cost_eur
from usage_metrics
group by 1;

-- Trigger updated_at pour usage_metrics (r√©utilise set_updated_at)
drop trigger if exists trg_usage_metrics_updated_at on usage_metrics;
create trigger trg_usage_metrics_updated_at
before update on usage_metrics
for each row execute procedure set_updated_at();
```

### 5.4 RLS (Phase 1.5 ‚Äî apr√®s liaison Clerk‚ÜîSupabase JWT)
> Pour le MVP, on peut s√©curiser **c√¥t√© serveur** (service role) et **activer RLS apr√®s**. Voici un exemple **indicatif** si vous propagez l‚ÄôID Clerk dans le JWT (`sub`).
```sql
-- Activer RLS
alter table patients enable row level security;
alter table visits enable row level security;
alter table transcripts enable row level security;
alter table notes enable row level security;

-- Helper: r√©cup√©rer le sub du JWT (Clerk user id)
-- select current_setting('request.jwt.claims', true)::jsonb->>'sub';

-- Policy: un utilisateur ne voit que ses patients
create policy pt_own_patients on patients
for select using (
  exists (
    select 1 from profiles p
    where p.id = patients.owner_id
      and p.clerk_user_id = (current_setting('request.jwt.claims', true)::jsonb->>'sub')
  )
);

-- M√™me logique pour visits
create policy pt_own_visits on visits
for select using (
  exists (
    select 1 from patients pa join profiles pr on pr.id = pa.owner_id
    where pa.id = visits.patient_id
      and pr.clerk_user_id = (current_setting('request.jwt.claims', true)::jsonb->>'sub')
  )
);

-- Idem pour transcripts, notes (via la jointure sur visits ‚Üí patients ‚Üí profiles)
```

**‚ö†Ô∏è Important** : Ces policies supposent que votre API transmet un JWT contenant `sub = clerk_user_id`. Tant que ce n‚Äôest pas en place, **gardez RLS d√©sactiv√©** et appliquez des **v√©rifications d‚Äôownership c√¥t√© serveur** (via Clerk `userId`).

### 5.5 Index & perfs
- Index sur **toutes les FK** (`owner_id`, `patient_id`, `provider_id`, `visit_id`).
- `created_at`/`updated_at` : utilisables pour l‚Äôordre d‚Äôaffichage et la purge.

### 5.6 Check-list ¬´ √Ä cr√©er dans Supabase ¬ª
- [ ] Cr√©er le **projet Supabase** en **r√©gion EU**.
- [ ] Ex√©cuter le **SQL** de la section 5.3.
- [ ] (Optionnel P1.5) Activer **RLS** + Policies quand le **JWT Clerk** (claim `sub`) est en place.
- [ ] Ajouter des **v√©rifications d‚Äôownership** dans **toutes les routes API** (Clerk `userId` ‚Üî `profiles.clerk_user_id`).


### 5.7 Synchronisation Clerk ‚Üî Supabase (MVP)
- **Alternative plus simple (recommand√©e)** : **Webhook Clerk ‚Üí Supabase Edge Function** pour la **sync automatique** des utilisateurs vers la table `profiles`.
- **√âv√©nements** : `user.created`, `user.updated`, `user.deleted`.
- **Action** : **UPSERT** `profiles (clerk_user_id, email, full_name)` ; sur `user.deleted` ‚Üí **soft delete** via `profiles.deleted_at` (si pr√©sent).
- **S√©curit√©** : v√©rification **Svix** de la signature webhook ; utiliser la **Service Role Key** dans l‚ÄôEdge Function (jamais dans le middleware/client).
- **B√©n√©fices** : idempotent, pas de latence √† chaque requ√™te, surface d‚Äôattaque r√©duite.
- **Option fallback** : √† d√©faut, *lazy create* lors de la **premi√®re action serveur authentifi√©e** (UPSERT si absent).

---

### URL & Configuration
- **Function name** : `clerk-sync`  
- **URL √† configurer dans Clerk ‚Üí Webhooks** :  
  `https://<PROJECT>.supabase.co/functions/v1/clerk-sync`
- **√âv√©nements √† √©couter** : `user.created`, `user.updated`, `user.deleted`

### Secrets requis (Supabase)
- `CLERK_WEBHOOK_SECRET` ‚Äî cl√© de signature g√©n√©r√©e par Clerk.  
- `SUPABASE_SERVICE_ROLE_KEY` ‚Äî cl√© Service Role (jamais c√¥t√© client).  
- `SUPABASE_URL` ‚Äî d√©j√† configur√©e dans le projet Supabase.

### Exemple d‚ÄôEdge Function
```ts
// supabase/functions/clerk-sync/index.ts
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import { Webhook } from 'https://esm.sh/svix@1.4.9'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.38.4'

serve(async (req) => {
  const payload = await req.text()
  const headers = Object.fromEntries(req.headers)
  
  // V√©rification Svix
  const wh = new Webhook(Deno.env.get('CLERK_WEBHOOK_SECRET')!)
  const evt = wh.verify(payload, headers)
  
  const supabase = createClient(
    Deno.env.get('SUPABASE_URL')!,
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
  )
  
  if (evt.type === 'user.created' || evt.type === 'user.updated') {
    await supabase.from('profiles').upsert({
      clerk_user_id: evt.data.id,
      email: evt.data.email_addresses[0]?.email_address,
      full_name: `${evt.data.first_name} ${evt.data.last_name}`.trim()
    }, { onConflict: 'clerk_user_id' })
  }

  if (evt.type === 'user.deleted') {
    await supabase.from('profiles')
      .update({ deleted_at: new Date().toISOString() })
      .eq('clerk_user_id', evt.data.id)
  }
  
  return new Response('ok', { status: 200 })
})
```

### Fallback ‚Äúlazy create‚Äù (dans les routes serveur)
```ts
// Exemple √† inclure dans les routes API prot√©g√©es
const clerkUserId = auth().userId
const profile = await db.select('profiles').eq('clerk_user_id', clerkUserId).single()

if (!profile) {
  await db.from('profiles').upsert({
    clerk_user_id: clerkUserId,
    email: user.primaryEmailAddress?.emailAddress ?? null,
    full_name: `${user.firstName ?? ''} ${user.lastName ?? ''}`.trim()
  }, { onConflict: 'clerk_user_id' })
}
```

> ‚úÖ Cette impl√©mentation assure la synchronisation fiable entre Clerk et Supabase (cr√©ation, mise √† jour, suppression d‚Äôutilisateurs) avec v√©rification Svix, idempotence, et fallback automatique si le webhook √©choue.


# 

---

## 6) Strat√©gie co√ªts & routing IA (MVP)


### 6.1 D√©cision MVP : un seul mod√®le STT & un seul mod√®le LLM

- **STT** : utiliser **un seul mod√®le** Deepgram `nova-3` pour **toutes** les dict√©es (DE par d√©faut).
- **LLM** : utiliser **un seul mod√®le** OpenAI via Azure, avec le d√©ploiement `gpt-4o-mini-eu`, pour **toutes** les g√©n√©rations SOAP **d√©taill√©es**.


### 6.2 Principes de base (MVP)
- **Mod√®le unique** : `nova-3` (STT) et `gpt-4o-mini-eu` (LLM) pour toutes les visites.
- **Limiter le contexte** : ne pas envoyer plus de texte que n√©cessaire (transcript nettoy√©).
- **Idempotence** : si le transcript n'a pas chang√©, ne pas reg√©n√©rer la SOAP (hash de contenu).
- **Hard caps** : plafond tokens (1024) pour √©viter les d√©rapages.

### 6.3 Garde‚Äëfous co√ªts
- **Max tokens** : plafonner les tokens de sortie (ex. 700‚Äì900 mots) et imposer la **sortie JSON stricte** pour √©viter le bavardage.
- **Nettoyage** : retirer les h√©sitations, doublons, m√©tadonn√©es du transcript avant d‚Äôappeler le LLM.
- **Pas de r√©g√©n√©ration inutile** : reg√©n√©rer **uniquement** si le transcript/texte **a chang√©** (hash du contenu en base).
- **Aper√ßu de co√ªt** (facultatif) : afficher ‚Äúco√ªt estim√©‚Äù avant g√©n√©ration.


### 6.4 Param√®tres (ENV) propos√©s
> Configuration unifi√©e de l‚Äôenvironnement (Azure OpenAI EU + Deepgram Streaming), avec valeurs indicatives de tarifs 2025.
```env
# Azure OpenAI (EU uniquement)
AZURE_OPENAI_ENDPOINT=https://<resource>.openai.azure.com
AZURE_OPENAI_API_KEY=***
AZURE_OPENAI_REGION=germanywestcentral   # ex: westeurope | francecentral | northeurope | switzerlandnorth ...
AZURE_OPENAI_DEPLOYMENT=gpt-4o-mini-eu  # nom de d√©ploiement Azure (pas le nom g√©n√©rique)
AZURE_OPENAI_API_VERSION=2024-02-01
LLM_MAX_OUTPUT_TOKENS=1024

# Deepgram STT (Streaming)
DEEPGRAM_API_KEY=***
DEEPGRAM_MODEL=nova-3
DEEPGRAM_LANGUAGE=de
STT_MAX_DURATION_SEC=900

# WebSocket (Streaming)
WS_TIMEOUT_MS=30000
WS_HEARTBEAT_INTERVAL_MS=10000

# Co√ªts (centimes EUR, valeurs indicatives 2025)
# Deepgram Nova-3 (pay-as-you-go, centimes EUR/seconde)
STT_RATE_CENTS_PER_SEC=0.16   # ~$0.0043/sec √ó 1.1 (taux EUR/USD) √ó 100 = 0.47 centimes

# Azure OpenAI gpt-4o-mini (centimes EUR/1K tokens)
LLM_IN_CENTS_PER_1K=0.013     # ~$0.00015/1K √ó 1.1 √ó 100 = 0.0165 centimes
LLM_OUT_CENTS_PER_1K=0.052    # ~$0.00060/1K √ó 1.1 √ó 100 = 0.066 centimes

# Tarifs √† v√©rifier sur :
# - Deepgram : https://deepgram.com/pricing
# - Azure OpenAI : https://azure.microsoft.com/pricing/details/cognitive-services/openai-service/
```
> Les montants sont renseign√©s dans l‚Äôenvironnement (pas dans le code). Le total est calcul√© c√¥t√© base (`total_cost_cents`).

### 6.5 Table m√©triques (optionnelle)
Pour suivre tes co√ªts √† posteriori (estimation), ajouter une petite table :
```
usage_metrics( id, visit_id, stt_seconds, llm_chars_in, llm_model, est_cost_usd, created_at )
```
- Aliment√©e apr√®s chaque visite (approximation), elle t‚Äôaide √† ajuster les seuils.


### 6.6 Check‚Äëlist ‚Äú√† faire‚Äù
- [ ] Impl√©menter la **d√©tection de dur√©e** (STT) et la **d√©tection de complexit√©** (LLM) bas√©es sur la longueur/structure.
- [ ] Ajouter un **plafond de tokens** et la **sortie JSON stricte** c√¥t√© LLM.
- [ ] √âviter la r√©g√©n√©ration si **hash d‚Äôentr√©e inchang√©**.
- [ ] (Optionnel) Enregistrer une **m√©trique d‚Äôusage** par visite.

---

## 7) Prompt Engineering (MVP)

### 7.1 Objectif
Assurer des notes SOAP **structur√©es, d√©taill√©es et fiables** en **allemand**, minimiser les hallucinations, et garder des sorties **JSON strictes** faciles √† enregistrer et √† copier.

### 7.2 Principes
- **R√®gles explicites** : langue DE, pas d‚Äôinvention ‚Üí utiliser **"N/A"** si information absente.
- **Structure impos√©e** : JSON strict `{subjective, objective, assessment, plan}`.
- **Unit√© & m√©triques** : ROM en **degr√©s** (¬∞), force **0‚Äì5**, √©chelles (NRS/VAS 0‚Äì10), fr√©quence/volume du plan.
- **Style** : ton clinique, phrases courtes, **Stichpunkte** quand pertinent.
- **Longueur** : garder la sortie ‚â§ ~900 mots (plafond tokens en ENV).

### 7.3 Prompts ‚Äî DE ‚Äî syst√®me & utilisateur

```ts
export const SOAP_SYSTEM_DE = `
Du bist ein klinischer Assistent f√ºr Physiotherapie auf Deutsch.
Erzeuge eine **detaillierte SOAP-Notiz** aus Transkript oder Freitext.

REGELN:
- **Sprache**: Deutsch.
- **Nichts erfinden**: Fehlende Information = "N/A".
- **Struktur & Format**: Ausgabe ausschlie√ülich als JSON {subjective, objective, assessment, plan}.
- **Stil**: klinisch, pr√§zise, kurze S√§tze, Stichpunkte erlaubt.
- **Ziele**: nach M√∂glichkeit SMART (konkret, messbar, terminierbar).

ANFORDERUNGEN:
- SUBJEKTIV: Hauptbeschwerden, Schmerzskala (NRS/VAS 0‚Äì10), Verlauf, Red Flags (falls erw√§hnt).
- OBJEKTIV: Messwerte (ROM in Grad ¬∞), Kraftgrade (0‚Äì5), relevante Tests (z. B. Las√®gue, Hawkins-Kennedy), Beobachtungen.
- ASSESSMENT: Klinische Einsch√§tzung, Hypothesen, Irritabilit√§t (niedrig/mittel/hoch), Fortschritt seit letzter Sitzung (falls vorhanden).
- PLAN: Interventionen (mit Dosierung/Frequenz), HEP, Ziele nach SMART, n√§chste Schritte/Termine.
`;
```

```ts
// Le template utilisateur s‚Äôins√®re dynamiquement avec le transcript ou le texte saisi.
export const SOAP_USER_TEMPLATE_DE = ({
  rawText,
  detail = 'detailed',
  bodyRegion
}: { rawText: string; detail?: 'concise'|'detailed'; bodyRegion?: string }) => `
KONTEXT:
- Detailtiefe: ${detail === 'detailed' ? 'hoch (bitte Messwerte/Tests/Scores aufnehmen)' : 'mittel (nur Kernaussagen)'}
${bodyRegion ? `- Fokusregion: ${bodyRegion}` : ''}

TRANSKRIPTION/NOTIZEN:
"""
${rawText}
"""

HINWEIS:
- System-Regeln gelten (Deutsch, nichts erfinden ‚Üí "N/A", Ausgabe nur JSON).
`;
```

> Variante FR (future i18n) : cloner ces deux prompts en version fran√ßaise et basculer via `language_pref`.

### 7.4 Sch√©ma de sortie (validation)
Utiliser un sch√©ma pour forcer le JSON (ex. Zod) et rejeter toute sortie invalide.

```ts
import { z } from 'zod';
export const SoapSchema = z.object({
  subjective: z.string(),
  objective: z.string(),
  assessment: z.string(),
  plan: z.string(),
});
```

### 7.5 Bonnes pratiques (r√©sum√©)
- **Toujours** rappeler: "rien inventer ‚Üí N/A".
- **Nettoyer** le transcript en amont (enlever h√©sitations, m√©tadonn√©es, doublons).
- **Limiter** la longueur d‚Äôentr√©e (d√©couper/ou r√©sumer si besoin) et **plafonner** la sortie (ENV tokens).
- **Post‚Äëvalidation**: si un champ est vide ou invalide, reg√©n√©rer uniquement ce champ (ou demander saisie manuelle).
- **Tra√ßabilit√©**: stocker `model` et `version` dans `notes`.


### 7.6 Check‚Äëlist d‚Äôint√©gration
- [ ] Mettre `SOAP_SYSTEM_DE` c√¥t√© serveur et utiliser `SOAP_USER_TEMPLATE_DE` avec `rawText` (transcript ou saisie).
- [ ] Passer `language_pref` de la visite (par d√©faut `de`).
- [ ] Valider la r√©ponse avec `SoapSchema` et bloquer toute sortie non‚ÄëJSON.
- [ ] Ajouter un **bouton Reg√©n√©rer** (si n√©cessaire) et **Saisie manuelle** en fallback.
- [ ] Enregistrer dans `notes(model, version)` le mod√®le utilis√© et incr√©menter `version` √† chaque reg√©n√©ration.

---

## 8) UX Flow (MVP)

### 8.1 User Flow principal (Mermaid)
```mermaid
graph TD
    A[Login (Clerk, DE)] --> B{Patient existant ?}
    B -->|Non| C[Cr√©er Patient (Nom/Pr√©nom)]
    B -->|Oui| D[S√©lectionner Patient] 
    C --> D
    D --> E[Nouvelle Visite]
    E --> F{Mode de saisie?}
    F -->|Audio| G[Enregistrer (streaming temps r√©el)]
    F -->|Texte| H[Saisir manuellement]
    G --> I[Transcription live (WS Deepgram, retry 3x)]
    H --> J[G√©n√©rer SOAP (Azure OpenAI EU, retry 3x)]
    I --> J
    J --> K[R√©viser/√âditer (autosave, version)]
    K --> L[Sauvegarder (is_final ?)]
    L --> M[Copier (format√©, toast)]
    I -->|√©chec r√©p√©t√©| H
    J -->|√©chec r√©p√©t√©| H
```


### 8.2 D√©tails UX cl√©s
- **Pas de choix de langue** : tout est en allemand par d√©faut (multilingue viendra plus tard).
- **Pas de consentement UI** : le consentement patient est oral (MVP clinique r√©el).
- **Mode de saisie** : le kin√© choisit soit l‚Äôaudio, soit le texte manuel.
- **Fallback** : en cas d‚Äô√©chec r√©p√©t√© de la transcription ou de la g√©n√©ration SOAP, on propose la saisie manuelle.
- **Toasts** (notifications l√©g√®res, temporaires) :
  - ¬´ Transkription l√§uft‚Ä¶ Versuch 2/3 ¬ª
  - ¬´ Audio gel√∂scht (GDPR ok) ¬ª
  - ¬´ SOAP generiert ¬ª
  - ¬´ Fehler ‚Üí Manuelle Eingabe ? ¬ª

---

## 9) Monitoring & Analytics (MVP)

### 9.1 Analytics (Posthog/Mixpanel)
```ts
const analytics = {
  trackVisitFlow: (step: string, metadata: any) => {
    posthog.capture('visit_flow', {
      step,
      duration: metadata.duration,
      method: metadata.method,
      success: metadata.success
    })
  },
  
  trackPerformance: () => {
    // Temps de transcription
    // Temps de g√©n√©ration SOAP
    // Taux d'√©dition
    // Erreurs par √©tape
  }
}
```

### 9.2 Monitoring (Sentry)
```ts
Sentry.init({
  dsn: process.env.SENTRY_DSN,
  tracesSampleRate: 0.1,
  profilesSampleRate: 0.1
})
```