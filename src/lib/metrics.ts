// Cost tracking and metrics calculation utilities
// Based on PRD section 6: Cost Strategy & Routing

/**
 * Gets STT rate from environment (euro cents per second)
 */
export function getSttRateCentsPerSec(): number {
  const rate = process.env.STT_RATE_CENTS_PER_SEC;
  return rate ? parseFloat(rate) : 0.16; // Default: 0.16 cents/sec
}

/**
 * Gets LLM input rate from environment (euro cents per 1K tokens)
 */
export function getLlmInCentsPer1K(): number {
  const rate = process.env.LLM_IN_CENTS_PER_1K;
  return rate ? parseFloat(rate) : 0.013; // Default: 0.013 cents/1K
}

/**
 * Gets LLM output rate from environment (euro cents per 1K tokens)
 */
export function getLlmOutCentsPer1K(): number {
  const rate = process.env.LLM_OUT_CENTS_PER_1K;
  return rate ? parseFloat(rate) : 0.052; // Default: 0.052 cents/1K
}

/**
 * Calculates STT cost in euro cents
 * @param durationSeconds Audio duration in seconds
 * @returns Cost in euro cents
 */
export function calculateSttCost(durationSeconds: number): number {
  const rate = getSttRateCentsPerSec();
  return Math.round(durationSeconds * rate);
}

/**
 * Calculates LLM cost in euro cents
 * @param tokensIn Input tokens
 * @param tokensOut Output tokens
 * @returns Cost in euro cents
 */
export function calculateLlmCost(
  tokensIn: number,
  tokensOut: number
): number {
  const inRate = getLlmInCentsPer1K();
  const outRate = getLlmOutCentsPer1K();

  const inCost = (tokensIn / 1000) * inRate;
  const outCost = (tokensOut / 1000) * outRate;

  return Math.round(inCost + outCost);
}

/**
 * Calculates total visit cost (STT + LLM)
 * @param sttSeconds Audio duration in seconds
 * @param llmTokensIn LLM input tokens
 * @param llmTokensOut LLM output tokens
 * @returns Total cost in euro cents
 */
export function calculateTotalCost(
  sttSeconds: number,
  llmTokensIn: number,
  llmTokensOut: number
): number {
  const sttCost = calculateSttCost(sttSeconds);
  const llmCost = calculateLlmCost(llmTokensIn, llmTokensOut);
  return sttCost + llmCost;
}

/**
 * Formats cost in euro cents to EUR string
 * @param costCents Cost in euro cents
 * @returns Formatted EUR string (e.g., "€0.25")
 */
export function formatCostAsEur(costCents: number): string {
  const eur = costCents / 100;
  return new Intl.NumberFormat("de-DE", {
    style: "currency",
    currency: "EUR",
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  }).format(eur);
}

/**
 * Estimates token count from text (rough approximation)
 * Rule of thumb: ~4 characters per token for German text
 * @param text Input text
 * @returns Estimated token count
 */
export function estimateTokenCount(text: string): number {
  // Rough estimate: 1 token ≈ 4 characters for German
  return Math.ceil(text.length / 4);
}

/**
 * Estimates LLM cost from input text (before API call)
 * @param inputText Input text
 * @param expectedOutputTokens Expected output tokens (default: max from env)
 * @returns Estimated cost in euro cents
 */
export function estimateLlmCostFromText(
  inputText: string,
  expectedOutputTokens?: number
): number {
  const inputTokens = estimateTokenCount(inputText);
  const outputTokens =
    expectedOutputTokens ||
    parseInt(process.env.LLM_MAX_OUTPUT_TOKENS || "1024", 10);

  return calculateLlmCost(inputTokens, outputTokens);
}

/**
 * Creates usage metrics object ready for database insertion
 * @param params Metrics parameters
 * @returns Usage metrics object
 */
export function createUsageMetrics(params: {
  visitId: string;
  sttSeconds?: number;
  sttModel?: string;
  llmTokensIn?: number;
  llmTokensOut?: number;
  llmModel?: string;
}) {
  const {
    visitId,
    sttSeconds = 0,
    sttModel = "deepgram:nova-3",
    llmTokensIn = 0,
    llmTokensOut = 0,
    llmModel = "azure:gpt-4o-mini-eu",
  } = params;

  const sttCost = calculateSttCost(sttSeconds);
  const llmCost = calculateLlmCost(llmTokensIn, llmTokensOut);

  return {
    visit_id: visitId,
    stt_seconds: sttSeconds,
    stt_cost_cents: sttCost,
    stt_model: sttModel,
    llm_tokens_in: llmTokensIn,
    llm_tokens_out: llmTokensOut,
    llm_cost_cents: llmCost,
    llm_model: llmModel,
    // total_cost_cents is generated by database
  };
}

/**
 * Validates cost thresholds (alert if costs are unexpectedly high)
 * @param costCents Cost in euro cents
 * @returns Alert information if cost exceeds thresholds
 */
export function checkCostThresholds(costCents: number): {
  shouldAlert: boolean;
  level: "info" | "warning" | "critical";
  message: string;
} {
  // Thresholds in euro cents
  const WARNING_THRESHOLD = 50; // €0.50
  const CRITICAL_THRESHOLD = 100; // €1.00

  if (costCents >= CRITICAL_THRESHOLD) {
    return {
      shouldAlert: true,
      level: "critical",
      message: `Coût élevé détecté : ${formatCostAsEur(costCents)}. Vérifier les paramètres.`,
    };
  }

  if (costCents >= WARNING_THRESHOLD) {
    return {
      shouldAlert: true,
      level: "warning",
      message: `Coût inhabituel : ${formatCostAsEur(costCents)}. Surveillance recommandée.`,
    };
  }

  return {
    shouldAlert: false,
    level: "info",
    message: `Coût normal : ${formatCostAsEur(costCents)}.`,
  };
}

/**
 * Aggregates monthly usage from usage metrics
 * Helper for client-side calculations (DB view exists for server-side)
 */
export function aggregateMonthlyUsage(
  metrics: Array<{
    created_at: string;
    stt_seconds: number;
    total_cost_cents: number;
  }>
): Map<
  string,
  { month: string; visits: number; totalSttSeconds: number; totalCostEur: number }
> {
  const monthlyMap = new Map<
    string,
    { month: string; visits: number; totalSttSeconds: number; totalCostEur: number }
  >();

  metrics.forEach((metric) => {
    const date = new Date(metric.created_at);
    const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, "0")}`;

    const existing = monthlyMap.get(monthKey) || {
      month: monthKey,
      visits: 0,
      totalSttSeconds: 0,
      totalCostEur: 0,
    };

    existing.visits += 1;
    existing.totalSttSeconds += metric.stt_seconds;
    existing.totalCostEur += metric.total_cost_cents / 100;

    monthlyMap.set(monthKey, existing);
  });

  return monthlyMap;
}
